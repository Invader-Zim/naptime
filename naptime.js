var world_timezones =
[
    'Europe/Andorra',
    'Asia/Dubai',
    'Asia/Kabul',
    'Europe/Tirane',
    'Asia/Yerevan',
    'Antarctica/Casey',
    'Antarctica/Davis',
    'Antarctica/DumontDUrville', 
    'Antarctica/Mawson',
    'Antarctica/Palmer',
    'Antarctica/Rothera',
    'Antarctica/Syowa',
    'Antarctica/Troll',
    'Antarctica/Vostok',
    'America/Argentina/Buenos_Aires',
    'America/Argentina/Cordoba',
    'America/Argentina/Salta',
    'America/Argentina/Jujuy',
    'America/Argentina/Tucuman',
    'America/Argentina/Catamarca',
    'America/Argentina/La_Rioja',
    'America/Argentina/San_Juan',
    'America/Argentina/Mendoza',
    'America/Argentina/San_Luis',
    'America/Argentina/Rio_Gallegos',
    'America/Argentina/Ushuaia',
    'Pacific/Pago_Pago',
    'Europe/Vienna',
    'Australia/Lord_Howe',
    'Antarctica/Macquarie',
    'Australia/Hobart',
    'Australia/Currie',
    'Australia/Melbourne',
    'Australia/Sydney',
    'Australia/Broken_Hill',
    'Australia/Brisbane',
    'Australia/Lindeman',
    'Australia/Adelaide',
    'Australia/Darwin',
    'Australia/Perth',
    'Australia/Eucla',
    'Asia/Baku',
    'America/Barbados',
    'Asia/Dhaka',
    'Europe/Brussels',
    'Europe/Sofia',
    'Atlantic/Bermuda',
    'Asia/Brunei',
    'America/La_Paz',
    'America/Noronha',
    'America/Belem',
    'America/Fortaleza',
    'America/Recife',
    'America/Araguaina',
    'America/Maceio',
    'America/Bahia',
    'America/Sao_Paulo',
    'America/Campo_Grande',
    'America/Cuiaba',
    'America/Santarem',
    'America/Porto_Velho',
    'America/Boa_Vista',
    'America/Manaus',
    'America/Eirunepe',
    'America/Rio_Branco',
    'America/Nassau',
    'Asia/Thimphu',
    'Europe/Minsk',
    'America/Belize',
    'America/St_Johns',
    'America/Halifax',
    'America/Glace_Bay',
    'America/Moncton',
    'America/Goose_Bay',
    'America/Blanc-Sablon',
    'America/Toronto',
    'America/Nipigon',
    'America/Thunder_Bay',
    'America/Iqaluit',
    'America/Pangnirtung',
    'America/Atikokan',
    'America/Winnipeg',
    'America/Rainy_River',
    'America/Resolute',
    'America/Rankin_Inlet',
    'America/Regina',
    'America/Swift_Current',
    'America/Edmonton',
    'America/Cambridge_Bay',
    'America/Yellowknife',
    'America/Inuvik',
    'America/Creston',
    'America/Dawson_Creek',
    'America/Fort_Nelson',
    'America/Vancouver',
    'America/Whitehorse',
    'America/Dawson',
    'Indian/Cocos',
    'Europe/Zurich',
    'Africa/Abidjan',
    'Pacific/Rarotonga',
    'America/Santiago',
    'America/Punta_Arenas',
    'Pacific/Easter',
    'Asia/Shanghai',
    'Asia/Urumqi',
    'America/Bogota',
    'America/Costa_Rica',
    'America/Havana',
    'Atlantic/Cape_Verde',
    'America/Curacao',
    'Indian/Christmas',
    'Asia/Nicosia',
    'Asia/Famagusta',
    'Europe/Prague',
    'Europe/Berlin',
    'Europe/Copenhagen',
    'America/Santo_Domingo',
    'Africa/Algiers',
    'America/Guayaquil',
    'Pacific/Galapagos',
    'Europe/Tallinn',
    'Africa/Cairo',
    'Africa/El_Aaiun',
    'Europe/Madrid',
    'Africa/Ceuta',
    'Atlantic/Canary',
    'Europe/Helsinki',
    'Pacific/Fiji',
    'Atlantic/Stanley',
    'Pacific/Chuuk',
    'Pacific/Pohnpei',
    'Pacific/Kosrae',
    'Atlantic/Faroe',
    'Europe/Paris',
    'Europe/London',
    'Asia/Tbilisi',
    'America/Cayenne',
    'Africa/Accra',
    'Europe/Gibraltar',
    'America/Godthab',
    'America/Danmarkshavn',
    'America/Scoresbysund',
    'America/Thule',
    'Europe/Athens',
    'Atlantic/South_Georgia',
    'America/Guatemala',
    'Pacific/Guam',
    'Africa/Bissau',
    'America/Guyana',
    'Asia/Hong_Kong',
    'America/Tegucigalpa',
    'America/Port-au-Prince',
    'Europe/Budapest',
    'Asia/Jakarta',
    'Asia/Pontianak',
    'Asia/Makassar',
    'Asia/Jayapura',
    'Europe/Dublin',
    'Asia/Jerusalem',
    'Asia/Kolkata',
    'Indian/Chagos',
    'Asia/Baghdad',
    'Asia/Tehran',
    'Atlantic/Reykjavik',
    'Europe/Rome',
    'America/Jamaica',
    'Asia/Amman',
    'Asia/Tokyo',
    'Africa/Nairobi',
    'Asia/Bishkek',
    'Pacific/Tarawa',
    'Pacific/Enderbury',
    'Pacific/Kiritimati',
    'Asia/Pyongyang',
    'Asia/Seoul',
    'Asia/Almaty',
    'Asia/Qyzylorda',
    'Asia/Qostanay', 
    'Asia/Aqtobe',
    'Asia/Aqtau',
    'Asia/Atyrau',
    'Asia/Oral',
    'Asia/Beirut',
    'Asia/Colombo',
    'Africa/Monrovia',
    'Europe/Vilnius',
    'Europe/Luxembourg',
    'Europe/Riga',
    'Africa/Tripoli',
    'Africa/Casablanca',
    'Europe/Monaco',
    'Europe/Chisinau',
    'Pacific/Majuro',
    'Pacific/Kwajalein',
    'Asia/Yangon',
    'Asia/Ulaanbaatar',
    'Asia/Hovd',
    'Asia/Choibalsan',
    'Asia/Macau',
    'America/Martinique',
    'Europe/Malta',
    'Indian/Mauritius',
    'Indian/Maldives',
    'America/Mexico_City',
    'America/Cancun',
    'America/Merida',
    'America/Monterrey',
    'America/Matamoros',
    'America/Mazatlan',
    'America/Chihuahua',
    'America/Ojinaga',
    'America/Hermosillo',
    'America/Tijuana',
    'America/Bahia_Banderas',
    'Asia/Kuala_Lumpur',
    'Asia/Kuching',
    'Africa/Maputo',
    'Africa/Windhoek',
    'Pacific/Noumea',
    'Pacific/Norfolk',
    'Africa/Lagos',
    'America/Managua',
    'Europe/Amsterdam',
    'Europe/Oslo',
    'Asia/Kathmandu',
    'Pacific/Nauru',
    'Pacific/Niue',
    'Pacific/Auckland',
    'Pacific/Chatham',
    'America/Panama',
    'America/Lima',
    'Pacific/Tahiti',
    'Pacific/Marquesas',
    'Pacific/Gambier',
    'Pacific/Port_Moresby',
    'Pacific/Bougainville',
    'Asia/Manila',
    'Asia/Karachi',
    'Europe/Warsaw',
    'America/Miquelon',
    'Pacific/Pitcairn',
    'America/Puerto_Rico',
    'Asia/Gaza',
    'Asia/Hebron',
    'Europe/Lisbon',
    'Atlantic/Madeira',
    'Atlantic/Azores',
    'Pacific/Palau',
    'America/Asuncion',
    'Asia/Qatar',
    'Indian/Reunion',
    'Europe/Bucharest',
    'Europe/Belgrade',
    'Europe/Kaliningrad',
    'Europe/Moscow',
    'Europe/Simferopol',
    'Europe/Kirov',
    'Europe/Astrakhan',
    'Europe/Volgograd',
    'Europe/Saratov',
    'Europe/Ulyanovsk',
    'Europe/Samara',
    'Asia/Yekaterinburg',
    'Asia/Omsk',
    'Asia/Novosibirsk',
    'Asia/Barnaul',
    'Asia/Tomsk',
    'Asia/Novokuznetsk',
    'Asia/Krasnoyarsk',
    'Asia/Irkutsk',
    'Asia/Chita',
    'Asia/Yakutsk',
    'Asia/Khandyga',
    'Asia/Vladivostok',
    'Asia/Ust-Nera',
    'Asia/Magadan',
    'Asia/Sakhalin',
    'Asia/Srednekolymsk',
    'Asia/Kamchatka',
    'Asia/Anadyr',
    'Asia/Riyadh',
    'Pacific/Guadalcanal',
    'Indian/Mahe',
    'Africa/Khartoum',
    'Europe/Stockholm',
    'Asia/Singapore',
    'America/Paramaribo',
    'Africa/Juba',
    'Africa/Sao_Tome',
    'America/El_Salvador',
    'Asia/Damascus',
    'America/Grand_Turk',
    'Africa/Ndjamena',
    'Indian/Kerguelen',
    'Asia/Bangkok',
    'Asia/Dushanbe',
    'Pacific/Fakaofo',
    'Asia/Dili',
    'Asia/Ashgabat',
    'Africa/Tunis',
    'Pacific/Tongatapu',
    'Europe/Istanbul',
    'America/Port_of_Spain',
    'Pacific/Funafuti',
    'Asia/Taipei',
    'Europe/Kiev',
    'Europe/Uzhgorod',
    'Europe/Zaporozhye',
    'Pacific/Wake',
    'America/New_York',
    'America/Detroit',
    'America/Kentucky/Louisville',
    'America/Kentucky/Monticello',
    'America/Indiana/Indianapolis',
    'America/Indiana/Vincennes',
    'America/Indiana/Winamac',
    'America/Indiana/Marengo',
    'America/Indiana/Petersburg',
    'America/Indiana/Vevay',
    'America/Chicago',
    'America/Indiana/Tell_City',
    'America/Indiana/Knox',
    'America/Menominee',
    'America/North_Dakota/Center',
    'America/North_Dakota/New_Salem',
    'America/North_Dakota/Beulah',
    'America/Denver',
    'America/Boise',
    'America/Phoenix',
    'America/Los_Angeles',
    'America/Anchorage',
    'America/Juneau',
    'America/Sitka',
    'America/Metlakatla',
    'America/Yakutat',
    'America/Nome',
    'America/Adak',
    'Pacific/Honolulu',
    'America/Montevideo',
    'Asia/Samarkand',
    'Asia/Tashkent',
    'America/Caracas',
    'Asia/Ho_Chi_Minh',
    'Pacific/Efate',
    'Pacific/Wallis',
    'Pacific/Apia',
    'Africa/Johannesburg'
];
//new Date().toLocaleString("en-US", {timeZone: "America/New_York"})
tzOffsetMap = new Map();
tzOffsetMap.set("America/Los_Angeles", "-0700");
tzOffsetMap.set("America/Chicago", "-0500");
tzOffsetMap.set("America/New_York", "-0400");
tzOffsetMap.set("Europe/London", "+0100");

function zeroPad(num, places) {
    var zero = places - num.toString().length + 1;
    return Array(+(zero > 0 && zero)).join("0") + num;
}

function millisecondsToHHMM(ms) {
    return Math.trunc(ms/(3600*1000)) + ":" + zeroPad(Math.trunc(ms/(60*1000))%60, 2);
}

class TimeOfDay {

    constructor(tod) {
        this.tod = tod;
    }

    toDate(date, tz) {
        //This broken.  The date in the destination may be different than the date in the depart tz.
        var dateInTz = new Date(date).toLocaleString("en-US", {timeZone: tz});
        let aDateSegments = dateInTz.split( '/' );
        let month = parseInt(aDateSegments[0]);
        let dom = parseInt(aDateSegments[1]);
        let year = parseInt(aDateSegments[2]);
        //console.log(dateInTz);

        let todVal = parseInt(this.tod, 10);
        let todH = parseInt(todVal/100)%36;//We allow for hours > 23.  This just means tod into the next day (up to noon the next day)
        let todM = parseInt(todVal%100)%60;
        let offsetHours = tzOffsetMap.get(tz);
        var str = year + "-" + zeroPad(month, 2) + "-" + zeroPad(dom, 2) + "T" + zeroPad(todH%24, 2) + ":" + zeroPad(todM, 2) + ":00.000" + offsetHours;
        var dt = new Date(str);
        //console.log(str);
        //console.log(dt);
        return dt;
    }

    toString() {
        var dtTemp = new Date();
        let todVal = parseInt(this.tod, 10);
        let todH = parseInt(todVal/100)%36;//We allow for hours > 23.  This just means tod into the next day (up to noon the next day)
        let todM = parseInt(todVal%100)%60;
        dtTemp.setHours(0,0,0,0);
        var dt = new Date(dtTemp.getTime() + (todH*3600*1000 + todM*60*1000));
        var plusDay = "";
        if ( todH > 23 ) {
            plusDay = " +1";
        }
        return dt.toLocaleTimeString([], {timeStyle: 'short'}) + plusDay;
    }
}

class TravelSegment {

    constructor(departDate, departPlace, departTZ, arriveDate, arrivePlace, arriveTZ) {
        this.departDate = departDate;
        this.departPlace = departPlace;
        this.departTZ = departTZ;

        this.arriveDate = arriveDate;
        this.arrivePlace = arrivePlace;
        this.arriveTZ = arriveTZ;
    }

    getDurationSeconds() {
        return (this.arriveDate - this.departDate)/1000.0;
    }

    getDurationMinutes() {
        return this.getDurationSeconds()/60.0;
    }

    getDurationHours() {
        return this.getDurationMinutes()/60.0;
    }

    getDurationHHMM() {
        return millisecondsToHHMM(this.arriveDate - this.departDate);
    }
}

class TimePeriod {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }

    duration() {
        return (this.end - this.start);
    }

    durationHours() {
        return this.duration() / (3600 * 1000);
    }

    midpoint() {
        return new Date(this.start.getTime() + this.duration()/2.0);
    }

    dateInPeriod(date) {
        return (date-this.start) > 0 && (date-this.end) < 0;
    }
}

class NapDetails {

    constructor(requiresModifiedNapTiming, napPeriod, remedy) {
        this.requiresModifiedNapTiming = requiresModifiedNapTiming
        this.napPeriod = napPeriod
        this.remedy = remedy;
    }
}


const NapError = {
    NapNoViolation:0,
    NapIsBeforeInitialDeparture:1,
    NapInBlackoutPeriod:2,
    NapViolatesFlightDayWakeTime:3,
    NapViolatesArrivalDaySleepTime:4
};

class TripOneWay {

    //Object Lifecycle
    constructor(departWake, departSleep, departDayLWT, dstWake, dstSleep, arrivalDayEBT) {
        this.departWake = new TimeOfDay(departWake);
        this.departDayLWT = new TimeOfDay(departDayLWT);
        this.departSleep = new TimeOfDay(departSleep);

        this.dstWake = new TimeOfDay(dstWake);
        this.dstSleep = new TimeOfDay(dstSleep);
        this.arrivalDayEBT = new TimeOfDay(arrivalDayEBT);

        this.itinerary = new Array();
    }

    initWithObject(tripOneWay) {
        this.departWake = new TimeOfDay(tripOneWay.departWake.tod);
        this.departDayLWT = new TimeOfDay(tripOneWay.departDayLWT.tod);
        this.departSleep = new TimeOfDay(tripOneWay.departSleep.tod);

        this.dstWake = new TimeOfDay(tripOneWay.dstWake.tod);
        this.dstSleep = new TimeOfDay(tripOneWay.dstSleep.tod);
        this.arrivalDayEBT = new TimeOfDay(tripOneWay.arrivalDayEBT.tod);

        this.itinerary = new Array();

        for (var leg of tripOneWay.itinerary) {
            let ts = new TravelSegment(new Date(leg.departDate), leg.departPlace, leg.departTZ, new Date(leg.arriveDate), leg.arrivePlace, leg.arriveTZ);
            this.itinerary.push(ts);
        }
    }

    //Helpers
    arrivalLeg() {
        return this.itinerary[this.itinerary.length-1];
    }

    dateDiffHours(date1, date2) {
        return (date1 - date2)/3600000.0;
    }

    departLeg() {
        return this.itinerary[0];
    }

    dateWithOffset(date, offsetHours) {
        return new Date(date.getTime() + (offsetHours*3600*1000));
    }

    generateBlackoutPeriods() {
        var blackouts = new Array();

        var prevLeg = null
        for (var leg of this.itinerary) {
            var blackoutStart0 = this.dateWithOffset(leg.departDate, -4.0);
            if ( prevLeg != null ) {
                //This is a layover - but since the prev leg blacks out up to 2 hrs after arrival, we start this blackout there.
                blackoutStart0 = this.dateWithOffset(prevLeg.arriveDate, 2.0);
            } else {
                blackoutStart0 = this.dateWithOffset(leg.departDate, -4.0);
            }
            let blackoutEnd0 = this.dateWithOffset(leg.departDate, 1.0);
            let blackout0 = new TimePeriod(blackoutStart0, blackoutEnd0);
            blackouts.push(blackout0);    


            let blackoutStart1 = this.dateWithOffset(leg.arriveDate, -1.0);
            let blackoutEnd1 = this.dateWithOffset(leg.arriveDate, 2.0);
            let blackout1 = new TimePeriod(blackoutStart1, blackoutEnd1);
            blackouts.push(blackout1);

            prevLeg = leg
        }
        return blackouts;
    }

    napConditionViolation( napPeriod, flightDayWakeTime, arrivalDaySleepTime) {
        /*
            Unallowed Nap Conditions.
                Naps are not allowed to be ongoing during any of the following times. If one of these conditions is
                breached, see the Rules for Modifying Nap Timing below.
                    1. Times surrounding flights
                        a. 4 hours before take off until 1 hour after take-off
                        b. 1 hours before landing until 2 hours after landing
                        c. During a layover
                    2. Proximity to Flight Day Wake Time and Arrival Day Bed Time
                        a. A Nap Length of 1 hours must start at least 4 hours after Flight Day Wake Time
                           and 6 hours before Arrival Day Bed Time
                        b. A Nap Length of 2 hours must start at least 6 hours after Flight Day Wake Time
                           and 8 hours before Arrival Day Bed Time
                        c. A Nap Length of 4 hours must start at least 9 hours after Flight Day Wake Time
                           and 10 hours before Arrival Day Bed Time
                        d. A Nap Length of 6 hours must start at least 12 hours after Flight Day Wake Time
                           and 12 hours before Arrival Day Bed Time
                        e. A Nap Length of 8 hours must start at least 14 hours after Flight Day Wake Time
                           and 12 hours before Arrival Day Bed Time
                    3. Maximum Time Awake
                        a. The traveler must not have a time period of more than 20 hours without sleep.
         */

        //Rules don't put it this way, but, a nap must occur after initial departure
        let departLeg = this.departLeg();
        if ( (departLeg.departDate - napPeriod.start) > 0 ) {
            //nap is before the initial departure
            //this seems like an error condition
            return NapError.NapIsBeforeInitialDeparture;
        }

        let blackouts = this.generateBlackoutPeriods()
        for (var blackout of blackouts) {
            if ( (napPeriod.start - blackout.start) > 0 && (napPeriod.start - blackout.end) < 0 ) {
                return NapError.NapInBlackoutPeriod;//nap starts in a blackout period
            }
            if ( (napPeriod.end - blackout.start) > 0 && (napPeriod.end - blackout.end) < 0 ) {
                return NapError.NapInBlackoutPeriod;//nap ends in a blackout period
            }
        }

        let napLengthHours = napPeriod.durationHours();
        if ( napLengthHours >= 8.0 ) {
            if ( this.dateDiffHours(napPeriod.start, flightDayWakeTime) < 14.0 ) {
                return NapError.NapViolatesFlightDayWakeTime;
            }
            if ( this.dateDiffHours(arrivalDaySleepTime, napPeriod.start) < 12.0 ) {
                return NapError.NapViolatesArrivalDaySleepTime;
            }
        } else if ( napLengthHours >= 6.0 ) {
            if ( this.dateDiffHours(napPeriod.start, flightDayWakeTime) < 12.0 ) {
                return NapError.NapViolatesFlightDayWakeTime;
            }
            if ( this.dateDiffHours(arrivalDaySleepTime, napPeriod.start) < 12.0 ) {
                return NapError.NapViolatesArrivalDaySleepTime;
            }
        } else if ( napLengthHours >= 4.0 ) {
            if ( this.dateDiffHours(napPeriod.start, flightDayWakeTime) < 9.0 ) {
                return NapError.NapViolatesFlightDayWakeTime;
            }
            if ( this.dateDiffHours(arrivalDaySleepTime, napPeriod.start) < 10.0 ) {
                return NapError.NapViolatesArrivalDaySleepTime;
            }
        } else if ( napLengthHours >= 2.0 ) {
            if ( this.dateDiffHours(napPeriod.start, flightDayWakeTime) < 6.0 ) {
                return NapError.NapViolatesFlightDayWakeTime;
            }
            if ( this.dateDiffHours(arrivalDaySleepTime, napPeriod.start) < 8.0 ) {
                return NapError.NapViolatesArrivalDaySleepTime;
            }
        } else if ( napLengthHours >= 1.0 ) {
            if ( this.dateDiffHours(napPeriod.start, flightDayWakeTime) < 4.0 ) {
                return NapError.NapViolatesFlightDayWakeTime;
            }
            if ( this.dateDiffHours(arrivalDaySleepTime, napPeriod.start) < 6.0 ) {
                return NapError.NapViolatesArrivalDaySleepTime;
            }
        }

        return NapError.NapNoViolation;
    }
    
    /*
     * This is the time between blackout periods whose duration > than the specified time
     */
    napablePeriods( minSpanMilliseconds ) {
        var nonBlackouts = new Array();

        let blackouts = this.generateBlackoutPeriods();
        var prevBlackout = null
        for (var blackout of blackouts) {
            if ( prevBlackout != null && (blackout.start - prevBlackout.end) > minSpanMilliseconds ) {
                let napablePeriod = new TimePeriod(prevBlackout.end, blackout.start);
                nonBlackouts.push(napablePeriod);
            }
            prevBlackout = blackout;
        }
        /*
         * I presume we allow napping after arrival??  I will presume, for now, that all trips result
         * in a nap during a flight.  In a more complete implementation, my guess is, multiple naps are
         * accounted for; and in that case, I would expect a nap on arrival day is possible.
         */
        return nonBlackouts;
    }


    //Public accessors
    addLeg(travelSegment) {
        this.itinerary.push(travelSegment);
    }

	arrivalDaySleepTimeOfDay() {
        let dt = this.arrivalLeg().arriveDate;
        let tz = this.arrivalLeg().arriveTZ;
        if ( this.dstSleep.toDate(dt, tz) > this.arrivalDayEBT.toDate(dt, tz) ) {
            return this.dstSleep;
        }
        return this.arrivalDayEBT;
    }

	departureDayWakeTimeOfDay() {
        let dt = this.departLeg().departDate;
        let tz = this.departLeg().departTZ;
        if ( this.departWake.toDate(dt, tz) < this.departDayLWT.toDate(dt, tz) ) {
            return this.departWake;
        }
        return this.departDayLWT;
    }

    napLengthHours() {
        /*
            Calculation of Nap Length
            1. Take the number of hours between Flight Day Wake Time and Arrival Day Bed Time. This is Total Wakefulness.
            2. Nap Length is determined as follows from Total Wakefulness:
                a. 20≤ Total Wakefulness, No nap
                b. 20< Total Wakefulness ≤ 24, Nap Length = 1 hours
                c. 24< Total Wakefulness ≤28, Nap Length = 2 hours
                d. 28< Total Wakefulness ≤ 36, Nap Length = 4 hours
                e. 36< Total Wakefulness ≤ 42, Nap Length = 6 hours
                f. 42< Total Wakefulness, Nap Length = 8 hours
         */
        let totalWakefulness = this.totalWakefulnessHours();
        if ( totalWakefulness <= 20 ) {
            return 0.0;
        } else if ( totalWakefulness <= 24 ) {
            return 1.0;
        } else if ( totalWakefulness <= 28 ) {
            return 2.0;
        } else if ( totalWakefulness <= 36 ) {
            return 4.0;
        } else if ( totalWakefulness <= 42 ) {
            return 6.0;
        }
        return 8.0;
    }

    napDetails() {
        let departLeg = this.departLeg();
        let arrivalLeg = this.arrivalLeg();

        let flightDayWakeTime = this.departureDayWakeTimeOfDay().toDate(departLeg.departDate, departLeg.departTZ);
        let arrivalDaySleepTime = this.arrivalDaySleepTimeOfDay().toDate(arrivalLeg.arriveDate, arrivalLeg.arriveTZ);
        let napLengthMS = this.napLengthHours()*(3600 * 1000);

        return this.napDetails2(napLengthMS, flightDayWakeTime, arrivalDaySleepTime, true);
    }

    /*
     * This is for debugging / informational purposes.  This is the nap BEFORE any remedies
     */
    napPeriodNoRemedies() {
        let departLeg = this.departLeg();
        let arrivalLeg = this.arrivalLeg();

        let flightDayWakeTime = this.departureDayWakeTimeOfDay().toDate(departLeg.departDate, departLeg.departTZ);
        let arrivalDaySleepTime = this.arrivalDaySleepTimeOfDay().toDate(arrivalLeg.arriveDate, arrivalLeg.arriveTZ);
        let napLengthMS = this.napLengthHours()*(3600 * 1000);

        let dateUsualSleep = this.departSleep.toDate(departLeg.departDate, departLeg.departTZ);//time of day on the date and place of departure
        let preferredWake = this.dstWake.toDate(arrivalLeg.arriveDate, arrivalLeg.arriveTZ);//time of day on the date and place of arrival

        //milliseconds from dateUsualSleep
        let midpointMS = (preferredWake - dateUsualSleep)/2.0;

        let napStartMS = midpointMS - napLengthMS/2.0;
        let napStart = new Date(dateUsualSleep.getTime() + napStartMS);
        let napEnd = new Date(napStart.getTime() + napLengthMS);
        var napPeriod = new TimePeriod(napStart, napEnd);

        return napPeriod;
    }

    /*
     * This method allows for tweaking the values, and may call itself recursively
     */
    napDetails2(napLengthMS, flightDayWakeTime, arrivalDaySleepTime, performRemedies) {
        /*
            Nap Placement
                The Nap Start and End Time should be placed so that the midpoint of the nap is placed halfway between
                the time/date you would usually go to sleep the evening of your flight departure (Usual Bed Time (Home)
                for the flight departure day) and the time you would normally like to be waking up the day you arrive
                at your destination (Preferred Wake Time (Destination) for the flight arrival day, even if this happens
                before your flight arrives), unless this creates an unallowed nap condition. As a note, the Preferred
                Wake Time (Destination) can be before the Usual Bed Time (Home).
         */

        //usual bed time
        let departLeg = this.departLeg();
        let dateUsualSleep = this.departSleep.toDate(departLeg.departDate, departLeg.departTZ);//time of day on the date and place of departure

        let arrivalLeg = this.arrivalLeg();
        let preferredWake = this.dstWake.toDate(arrivalLeg.arriveDate, arrivalLeg.arriveTZ);//time of day on the date and place of arrival

        //milliseconds from dateUsualSleep
        let midpointMS = (preferredWake - dateUsualSleep)/2.0;

        let napStartMS = midpointMS - napLengthMS/2.0;
        let napStart = new Date(dateUsualSleep.getTime() + napStartMS);
        let napEnd = new Date(napStart.getTime() + napLengthMS);
        var napPeriod = new TimePeriod(napStart, napEnd);


        let napViolation = this.napConditionViolation(napPeriod, flightDayWakeTime, arrivalDaySleepTime);
        //We might be able to be smart about the remedies; but for now, we'll mostly treat the violation code as a black box.

        if ( NapError.NapNoViolation == napViolation ) {
            //done
        } else if ( NapError.NapIsBeforeInitialDeparture == napViolation ) {
            return null;//nothing can be done - this shouldn't happen
        } else if ( !performRemedies ) {
            return null;
        } else {
            if ( NapError.NapInBlackoutPeriod == napViolation ) {
                //remedy 1 - shift the nap time around - only works if the violation was related to blackout periods
                let napPeriodAlt = this.napDateRemedy1(napPeriod);
                if ( napPeriodAlt != null ) {
                    return new NapDetails(true, napPeriodAlt, "Remedy 1 (shift nap time)");
                }
                //Shifting the time didn't solve the problem, we'll fall through to decreasing the nap duration (remedy4)
            }

            if ( napViolation == NapError.NapViolatesFlightDayWakeTime ) {
                //remedy 2: adjust the flightDayWakeTime
                let napPeriodAlt = this.napDateRemedy2(napLengthMS, flightDayWakeTime, arrivalDaySleepTime);
                if ( napPeriodAlt != null ) {
                    return new NapDetails(true, napPeriodAlt, "Remedy 2 (adjust wake time)");
                }
            }

            if ( napViolation == NapError.NapViolatesArrivalDaySleepTime ) {
                //remedy 3: adjust the arrivalDaySleepTime
                let napPeriodAlt = this.napDateRemedy3(napLengthMS, flightDayWakeTime, arrivalDaySleepTime);
                if ( napPeriodAlt != null ) {
                    return new NapDetails(true, napPeriodAlt, "Remedy 3 (adjust arrival day sleep time)");
                }
            }

            let napPeriodAlt = this.napDateRemedy4(napLengthMS, flightDayWakeTime, arrivalDaySleepTime);
            if ( napPeriodAlt != null ) {
                return new NapDetails(true, napPeriodAlt, "Remedy 4 (adjust nap duration)");
            }
            
            return null;
        }
        return new NapDetails(false, napPeriod, "No nap adjustments required");
    }

    napDateRemedy1(napPeriod) {
        let napPeriodMid = napPeriod.midpoint();

        let napCandidatePeriods = this.napablePeriods(napPeriod.duration());
        if ( napCandidatePeriods.length == 0 ) {
            return null;
        }
            
        /*  This is redundant - the code below will handle this.
            for (var napCandidatePeriod of napCandidatePeriods) {
                if ( napCandidatePeriod.dateInPeriod(napPeriodMid) ) {
                    //Adjust
                    var napPeriodAlt = null
                    if ( !napCandidatePeriod.dateInPeriod(napPeriod.start) ) {
                        //need to move the start time to the candidate start
                        napPeriodAlt = new TimePeriod(napCandidatePeriod.start, new Date(napCandidatePeriod.start.getTime() + napLengthMS));
                    } else {
                        //need to move the end time to the candidate end
                        napPeriodAlt = new TimePeriod(new Date(napCandidatePeriod.end.getTime() - napLengthMS), napCandidatePeriod.end);
                    }
                    return napPeriodAlt;
                }
            }
        */

        //if the midpoint isn't in any of the napCandidatePeriods, then put the nap into the napCandidatePeriod with the closest midpoint
        var bestCandidatePeriod = null
        for (var napCandidatePeriod of napCandidatePeriods) {
            if (bestCandidatePeriod == null) {
                bestCandidatePeriod = napCandidatePeriod;
            } else {
                let proximityCur = napCandidatePeriod.midpoint() - napPeriod.midpoint;
                let proximityBest = bestCandidatePeriod.midpoint() - napPeriod.midpoint;
                if ( Math.abs(proximityCur) < Math.abs(proximityBest) ) {
                    bestCandidatePeriod = napCandidatePeriod;
                }
            }
        }

        let proximityBest = bestCandidatePeriod.midpoint() - napPeriod.midpoint();
        var napPeriodAlt = null
        if ( proximityBest > 0 ) {
            //need to move the start time to the candidate start
            napPeriodAlt = new TimePeriod(bestCandidatePeriod.start, new Date(bestCandidatePeriod.start.getTime() + napPeriod.duration()));
        } else {
            //need to move the end time to the candidate end
            napPeriodAlt = new TimePeriod(new Date(bestCandidatePeriod.end.getTime() - napPeriod.duration()), bestCandidatePeriod.end);
        }
        return napPeriodAlt;
    }

    napDateRemedy2(napLengthMS, flightDayWakeTime, arrivalDaySleepTime) {
        let flightDayLatestWakeTime = this.departDayLWT.toDate( this.departLeg().departDate, this.departLeg().departTZ );
        var napDetails = null;

        for(flightDayWakeTimeOffsetHours = 0; flightDayWakeTimeOffsetHours <= 1.5; flightDayWakeTimeOffsetHours += 0.1) {
            let flightDayWakeTimeCur0 = this.dateWithOffset(flightDayWakeTime, flightDayWakeTimeOffsetHours);
            if ( (flightDayLatestWakeTime - flightDayWakeTimeCur0) > 0 ) {
                napDetails = this.napDetails2(napLengthMS, flightDayWakeTimeCur0, arrivalDaySleepTime, false);
                if ( napDetails != null ) {
                    return napDetails.napPeriod;
                }
            }

            let flightDayWakeTimeCur1 = this.dateWithOffset(flightDayWakeTime, -1.0 * flightDayWakeTimeOffsetHours);
            napDetails = this.napDetails2(napLengthMS, flightDayWakeTimeCur1, arrivalDaySleepTime, false);
            if ( napDetails != null ) {
                return napDetails.napPeriod;
            }
        }
        return null;
    }

    napDateRemedy3(napLengthMS, flightDayWakeTime, arrivalDaySleepTime) {
        let arrivalDayEBT = this.arrivalDayEBT.toDate( this.arrivalLeg().arriveDate, this.arrivalLeg().arriveTZ );
        var napDetails = null;

        for(arrivalDaySleepTimeOffsetHours = 0; arrivalDaySleepTimeOffsetHours <= 1.5; arrivalDaySleepTimeOffsetHours += 0.1) {
            let arrivalDaySleepTimeCur0 = this.dateWithOffset(arrivalDaySleepTime, arrivalDaySleepTimeOffsetHours);
            napDetails = this.napDetails2(napLengthMS, flightDayWakeTime, arrivalDaySleepTimeCur0, false);
            if ( napDetails != null ) {
                return napDetails.napDetails;
            }

            let arrivalDaySleepTimeCur1 = this.dateWithOffset(arrivalDaySleepTime, -1.0 * arrivalDaySleepTimeOffsetHours);
            if ( (arrivalDayEBT - arrivalDaySleepTimeCur1) < 0 ) {
                napDetails = this.napDetails2(napLengthMS, flightDayWakeTime, arrivalDaySleepTimeCur1, false);
                if ( napDetails != null ) {
                    return napDetails.napDetails;
                }
            }
        }
        return null;
    }

    napDateRemedy4(napLengthMS, flightDayWakeTime, arrivalDaySleepTime) {
        //try 8,6,4,2,1 to see if any of those napLengths will work.
        let napCurrentLengthHours = napLengthMS / (3600*1000);
        var napLengths = [8,6,4,2,1];
        for(var napLengthHours of napLengths) {
            if ( napLengthHours >= napCurrentLengthHours ) {
                continue;
            }

            //If we need to further reduce the nap time, remedy 4 will be called recursively.
            //So no need to try all nap durations, just the one just less than the input.
            let napDetails = this.napDetails2(napLengthHours * (3600*1000), flightDayWakeTime, arrivalDaySleepTime, true);
            if ( napDetails != null ) {
                return napDetails.napPeriod;
            }
            return null;
        }
        return null;
    }


	timeZoneOffsetDepart() {

    }

	timeZoneOffsetDestination() {

    }

    totalWakefulnessMs() {
        let departureLeg = this.departLeg();
        let arrivalLeg = this.arrivalLeg();
        let dateDepartWake = this.departureDayWakeTimeOfDay().toDate(departureLeg.departDate, departureLeg.departTZ);
        let dateArriveSleep = this.arrivalDaySleepTimeOfDay().toDate(arrivalLeg.arriveDate, arrivalLeg.arriveTZ);
        return (dateArriveSleep - dateDepartWake);
    }

    totalWakefulnessHours() {
        return this.totalWakefulnessMs()/(3600 * 1000);
    }
}

if ( false ) {
    //This is debug code to help with the json syntax
    var tripOneWay = new TripOneWay("0715"/*home wake*/, "2330"/*home sleep*/, "0600"/*flight day latest wake */, "0600"/*dst wake*/, "2200"/*dst sleep*/, "2230"/*arrive day earliest sleep*/);

    var departSEA = new Date(2020, 7, 16, 10, 14, 0, 0);
    var arriveORD = new Date(2020, 7, 16, 16, 40, 0, 0);
    let leg0 = new TravelSegment(departSEA, "SEA", "America/Los_Angeles", arriveORD, "ORD", "America/Chicago");
    tripOneWay.addLeg(leg0);
    
    var departORD = new Date(2020, 7, 16, 18, 40, 0, 0);
    var arriveLHR = new Date(2020, 7, 17, 8, 30, 0, 0);
    let leg1 = new TravelSegment(departSEA, "ORD", "America/Chicago", arriveORD, "LHR", "Europe/London")
    tripOneWay.addLeg(leg1);
    
    console.log(JSON.stringify(tripOneWay));
} else {
    var tripJsonFile = "trip1.json";

    var myArgs = process.argv.slice(2);
    if ( myArgs.length > 0 ) {
        tripJsonFile = myArgs[0];
    }

    var fs = require('fs');
    var tripOneWayX = JSON.parse(fs.readFileSync(tripJsonFile, 'utf8'));
    
    var tripOneWay = new TripOneWay(null, null, null, null, null);
    tripOneWay.initWithObject(tripOneWayX)

    console.log("");
    var travelSegmentNumber = 0;
    var tripStart = null;
    var tripEnd = null;
    for (var segment of tripOneWay.itinerary) {
        ++travelSegmentNumber;

        if ( tripStart == null ) {
            tripStart = segment.departDate;
        }
        tripEnd = segment.arriveDate;

        console.log("Travel Segment " + travelSegmentNumber);
        console.log("    " + "    departs: " + segment.departDate);
        console.log("    " + "       from: " + segment.departPlace);
        console.log("    " + "    arrives: " + segment.arriveDate);
        console.log("    " + "         in: " + segment.arrivePlace);
        console.log("    " + "travel time: " + segment.getDurationHHMM());
        console.log("");
    }
    console.log("         segments: " + travelSegmentNumber);
    console.log("total travel time: " + millisecondsToHHMM(tripEnd - tripStart));
    console.log("     wakeful time: " + millisecondsToHHMM(tripOneWay.totalWakefulnessHours() * 3600000));
    console.log("");

    console.log("");
    console.log("Nap Blackout Periods");
    var blackouts = tripOneWay.generateBlackoutPeriods();
    for(var blackout of blackouts) {
        console.log("    " + "      start: " + blackout.start);
        console.log("    " + "        end: " + blackout.end);
        console.log("    " + "   duration: " + millisecondsToHHMM(blackout.duration()));
        console.log("");
    }

    let napDetails = tripOneWay.napDetails();
    if ( napDetails == null || napDetails.requiresModifiedNapTiming ) {
        let napPeriodNoRemedies = tripOneWay.napPeriodNoRemedies();

        console.log("Nap Details BEFORE Remedy:");
        console.log("       nap start: " + napPeriodNoRemedies.start);
        console.log("         nap end: " + napPeriodNoRemedies.end);
        console.log("    nap duration: " + napPeriodNoRemedies.durationHours() + " hours");
        console.log("");            
    }
    if ( napDetails == null ) {
        console.log("No remedies allow for a nap");
    } else {
        console.log("Nap Details:");
        console.log("    nap reqd mod: " + napDetails.requiresModifiedNapTiming);
        console.log("          remedy: " + napDetails.remedy);
        console.log("       nap start: " + napDetails.napPeriod.start);
        console.log("         nap end: " + napDetails.napPeriod.end);
        console.log("    nap duration: " + napDetails.napPeriod.durationHours() + " hours");
        console.log("");
        }
}


